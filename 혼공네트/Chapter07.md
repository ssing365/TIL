# 7-1 안정성을 위한 기술

- **가용성** : 웹서비스의 안정성을 수치로 표현한 것
    - 전체 사용 시간 중에서 **정상적인 사용 시간**
        
        ![스크린샷 2025-07-04 오후 10.35.15.jpg](./images/Chapter07/1.jpgjpg)
        
        - 업타임 - 정상적인 사용 시간
        - 다운타임 - 정상적인 사용이 불가능한 시간
    - **고가용성**(**HA**. High Availability) : 가용성이 높음
        - 모든 웹서비스 업체들의 **대단히 중요한 목표**
        
        ![스크린샷 2025-07-04 오후 10.37.27.jpg](./images/Chapter07/2.jpg.jpg)
        
        - 항상, 1초도 안 쉬고 잘 돌아가야하는 서비스에서는 파이브 나인스도 치명적
    - **가용성을 높이는 법?**
        
        ⇒ 다운 타임을 낮추면 된다.
        
        - 서비스는 왜 다운될까?
            - 과도한 트래픽
            - 예기치못한 SW상의 오류
            - 하드웨어 장애
            - 보안 공격, 자연재해 등
        - 원인을 모두 원천 차단하기는 힘들다.
        - 따라서 핵심은, **문제가 발생하더라도 계속 기능할 수 있도록 설계하는 것**
            - 이를 **결함 감내**라한다.
- 이중화
    
    : 결함을 감내하여 가용성을 높이기 위한 가장 기본적인 방법으로, **예비(백업)을 마련하는 방법**
    
    - 무엇을 이중화?
        - **문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상**
        - 이를 단일 장애점, **SPOF**(Single Point Of Failure)라고 한다.
            - ex) 서버 컴퓨터, NIC, 스위치, DB, 웹서버프로그램 등
    - 이중화 구성
        1. 액티브/스탠바이
            - 한 시스템은 가동하고, 다른 시스템은 백업 용도로 두는 이중화 구성 방식
            - 장점 : 안전하다
            - 단점 : 성능상 큰 변화는 없다.
        2. 액티브/액티브
            - 두 시스템 모두 가동 상태로 두는 구성 방식
            - 장점 : 부하분산을 할수있다. 성능상 이점이 있다.
            - 단점 : 한 시스템에 문제가 생기면 다른 시스템에 부하가 급증한다.
    - 다중화
        - 시스템을 세 개 이상으로 구성
    - 이중화/다중화 사례
        - **티밍(윈도우)과 본딩(리눅스)**
            - 여러 개의 NIC를 이중화/다중화하여 마치 더 뛰어난 성능을 보유한 하나의 인터페이스처럼 보이게 하는 기술
- 로드 밸런싱
    
    (고가용성을 요구하는 호스트는 일반적으로 클라가 아닌 서버, 서버 중심으로 얘기)
    
    - 서버를 이중화/다중화해도 문제는 남아있다. 바로 트래픽을 분산해야 의미가 있다는 것
    - 한 서버에 트래픽이 몰리면
        - 높은 부하로 CPU 발열 심해짐
        - 메모리 공간 부족
        - 제한된 대역폭과 병목 현상으로 응답이 느려지거나 누락될 수 있음
    
    ---
    
    - 해결 ⇒ 로드 밸런싱(load balancing)
        - load : 부하
        - balancing : 균형 유지
        - 로드 밸런서에 의해 수행된다.
            - L4스위치(전송계층)
            - L7스위치(응용계층)
            - 로드밸런싱 기능을 제공하는 소프트웨어
                - Nginx, HAProxy, Envoy
            
            ![스크린샷 2025-07-05 오전 11.33.03.jpg](./images/Chapter07/3.jpg)
            
        
        <aside>
        
        서버의 상태를 검사하는 헬스 체크
        
        - health check
            
            ![스크린샷 2025-07-05 오전 11.35.39.jpg](./images/Chapter07/4.jpg)
            
            - 서버들의 건강 상태를 주기적으로 모니터링하고 체크
            - 주로 로드 밸런서에 의해 이루어짐
            - HTTP, ICMP 등 다양한 프로토콜 활용
        - 헬스 체크 외에 서버 간의 메시지를 주기적으로 주고받아 상태를 검사하는 **하트비트**라는 방식도 있다.
        </aside>
        
    - 로드 밸런싱 알고리즘
        
        : 로드 밸런서가 부하를 분산시키기 위해 선택하는 방법
        
        1. 라운드 로빈 알고리즘
            
            ![스크린샷 2025-07-05 오전 11.40.23.jpg](./images/Chapter07/5.jpg)
            
            - 단순히 돌아가며 부하를 전달하는 방식
        2. 최소 연결 알고리즘
            - 연결이 적은 서버부터 우선적으로 전달하는 방식
        3. 기타
            - 무작위
            - 해시(hash) 자료구조 이용
            - 응답 시간이 가장 짧은 서버 선택
        - 가중치 라운드 로빈 알고리즘, 가중치 최소 연결 알고리즘
            
            ![스크린샷 2025-07-05 오전 11.40.10.jpg](./images/Chapter07/6.jpg)
            
            - 1,2번 알고리즘은 서버마다 가중치를 부여할 수 있다.
            - 가중치가 높은 서버가 더 많이 선택되어 더 많은 부하를 받도록 하는 것
            - 서버 간 성능이 다른 경우 주로 사용된다.
## 포워드 프록시와 리버스 프록시

- (HTTP)클라이언트는 서버와 단일하게 딱 붙어있지 않음
    - 실제로는 사이에 수많은 서버가 존재할 수 있고,
    - 서버는 다중화된 경우가 많다.

![스크린샷 2025-07-06 오후 3.08.37.jpg](./images/Chapter07/7.jpg)

- 오리진서버
    - 클라이언트가 최종적으로 메시지를 주고받는 대상
    - 자원을 생성하고 클라에게 권한 있는 응답을 보낼 수 있는 HTTP서버
    - 고가용성을 위해 다중화된 경우가 많다.
- 중간서버
    - 인바운드(inbound) 메시지 : 오리진 서버를 향하는 메시지
    - 아웃바운드(outbound) 메시지 : 클라이언트를 향하는 메시지
- 대표적인 HTTP 중간서버
    - 프록시(proxy, 포워드 프록시)
    - 게이트웨이(gateway, 리버스 프록시)

### 프록시(proxy)

- **클라이언트가 선택한** 메시지 전달 대리자
    - 프록시를 언제 어떻게 사용할지는 클라이언트가 선택하기 때문
- 특징
    - 오리진 서버보다 클라이언트와 더 가까이 위치
    - **캐싱, 클라이언트 암호화, 접근 제한 등**

![스크린샷 2025-07-06 오후 3.13.12.jpg](./images/Chapter07/8.jpg)

### 게이트웨이(gateway)

- 일반적 의미 : 네트워크 간의 통신을 가능케 하는 입구 역할을 하는 HW/SW
- HTTP 중간 서버 맥락에서의 의미
    - **아웃바운드 연결에 대해 오리진 서버 역할을 수행**하는 중개자
    - 수신된 요청 메시지를 다른 인바운드 서버들에 전달하는 중개자
- 특징
    - 클라이언트가 보기에 오리진 서버와 같이 보임
    - 클라이언트 요청을 오리진 서버에 전달하기 위해 오리진 서버들에 더 가까이 위치
    - **캐싱, 로드 밸런싱 수행**

![스크린샷 2025-07-06 오후 3.15.54.jpg](./images/Chapter07/9.jpg)

# 7-2 안전성을 위한 기술

### 암호와 인증서

- 먼 컴퓨터와 통신할 때 평문으로 메시지를 주고받으면 안된다. 암호화가 필요하다.
- 암호화
    - 원문 데이터를 알아볼 수 없는 형태로 변경하는 것
- 복호화
    - 암호화된 데이터를 원문 데이터로 되돌리는 과정
- 암호화 알고리즘
    - 데이터를 알아보기 어렵게 바꾸는 어떤 수학적 연산
- 암호화 복호화는 비단 안전한 데이터 송수신 뿐만 아니라 인증서 기반의 검증도 가능하게 한다.

### 대칭 키 암호화, 공개 키 암호화

- 대칭 키 암호화
    
    ![스크린샷 2025-07-07 오후 9.44.32.jpg](./images/Chapter07/a.jpg)
    
    - 암호화 하는 키와 복호화 하는 키가 같음
    - 장점
        - 작은 부하로 암호화 복호화가 빠르다.
    - 단점
        - 키를 안전하게 전송하기 어렵다.(키 안전하게 전송할 수 있으면 키 말고 그냥 원문 데이터를 안전하게 보내면 되는거 아녀)
- 공개 키 암호화(비대칭 키 암호화)
    
    ![스크린샷 2025-07-07 오후 9.59.42.jpg](./images/Chapter07/b.jpg)
    
    - 암호화에 사용되는 키와 복호화에 사용되는 키가 다름
    - 한 쌍의 키(공개 키, 개인 키)를 사용 : 한 키로 암호화, 다른 키로 복호화
    - 공개 키(public key)를 알아도 개인 키(private key) 유추 불가능. 역도 마찬가지
    - 공개 키는 암호화만 하고 개인 키를 유추할 수 없기 때문에 누구에게나 공개해도 무방하다.
    - 다시 받은 쪽에서 답장 메시지를 보낼때(B→A. 사실 A→B의 과정과 동일하다.)
        - A는 자신의 공개키를 B에게 전달
        - B는 A의 공개 키로 메시지를 암호화한 뒤 A에게 전송
        - A는 개인 키로 암호를 복호화해서 B의 메시지 확인
    - 장점
        - 키를 안전하게 공유할 수 있다
    - 단점
        - 암호화 및 복호화에 시간과 부하가 상대적으로 많이 든다.
### 인증서와 디지털 서명

> 앞서 본 암호화 기술을 기반으로 수행할 수 있는 인증, 디지털 서명
> 
- 인증서
    - 무엇인가를 증명하기 위한 문서
    - 네트워크(인터넷)에서의 인증서 = 일반적으로 ‘공개 키 인증서’

- 공개 키 인증서
    - ‘이 공개 키가 유효합니다.’ 인증하는 전자 문서
    - 공개 키와 공개 키의 유효성을 입증하기 위한 전자 문서
    
    ![image.png](./images/Chapter07/c.png)
    
    - 인증기관인 **CA**가 발급해줌
        - 통신 주체가 인증서를 가지고 있는건 의미가 없음(어케 믿어)
        - 인증서의 발급, 검증, 저장과 같은 역할을 수행할 수 있는 공인기관
        - 대표적인 인증 기관 - IdenTrust, DigiCert, GlobalSign 등
    - 서명 값(signature)
        
        ![image.png](./images/Chapter07/d.png)
        
        - 인증 기관의 인증 정보
        - 이 공개 키 인증서는 진짜임을 보증하는 것
        - 클라이언트는 CA가 발급한 인증서의 서명 값을 바탕으로 인증서 검증
        - 서명 값 생성의 원리
            
            ![image.png](./images/Chapter07/e.png)
            
            1. 인증서 내용에 대한 해시 값을
            2. CA의 개인 키로 암호화하는 방식으로 생성
                - CA는 이렇게 얻어낸 정보를 서명 값으로 삼아 클라이언트에게 인증서와 함께 전송
            
            ⇒ CA가 뿌린 공개키로 복호화가 됐다는건, CA가 개인키로 암호화한 데이터니까 CA가 인증한 인증서가 맞구나!를 알 수 있음
            
            - 1의 결과인 인증서 내용에 대한 해시 값을 fingerprint라고도 함
            
            <aside>
            💡
            
            해시 값?
            
            - 해시 함수를 적용시킨 결괏값
                - 해시 함수란
                    - 임의의 길이의 데이터를 고정된 길이의 데이터로 변환하는 함수
                    - MD5, SHA-1, SHA-2(SHA-256, SHA-384, SHA-512)등
                    - 입력값에 민감 : 입력 데이터가 조금만 달라져도 완전히 다른 결과가 나옴
            - 데이터 변조 여부 검사에 사용
                1. ‘보낼 데이터’ 와 ‘데이터에 대한 해시 값’을 함께 전송
                2. 수신자가 전달 받은 데이터에 대한 해시 값을 직접 계산
                3. 계산 결과를 전달 받은 해시 값과 비교
                4. 같은 값이 도출된다면 ⇒ 데이터 전송 도중 변조되거나 소실되지 않았다고 판단
            </aside>
            
    - 인증서 검증 과정
        
        ![image.png](./images/Chapter07/f.png)
        
        1. 서명 값과 인증서 분리
        2. 서명 값을 CA의 공개 키로 복호화하여 인증서 내용에 대한 해시 값을 얻음 
        3. 인증서 데이터에 대한 해시 값을 직접 계산
        4. 이를 복호화한 값과 비교
        
        → 만일 값이 일치한다면? 전달 받은 인증서는 확실히 CA의 개인 키로 만들어졌다고 보장
        
        ### 디지털 서명
        
        - 개인 키로 암호화된 메시지를 공개 키로 복호화함으로써 신원을 증명하는 절차

    ### HTTPS : SSL/TLS

- 지금까지 배운 대칭 키 / 공개 키 암호화, 그리고 공개 키 인증서를 기반으로 동작하는 프로토콜로 SSL과 TLS가 있다.
    - TLS는 SSL을 계승한 프로토콜이다.
- 이 SSL/TLS를 대표적으로 사용하는 프로토콜은 **HTTPS**(HTTP over TLS)이다.
    
    ![스크린샷 2025-07-10 오후 9.41.26.jpg](./images/Chapter07/h.jpg)
    

### HTTP 동작 과정(TLS 1.3 기반)

1. TCP 3-way 핸드셰이크
    1. SYN / SYN+ACK / ACK 세그먼트
2. **TLS 핸드셰이크**
3. 암호화된 메시지 송수신

### TLS 핸드셰이크

- 핵심
    1. 암호화 통신을 위한 키를 교환한다.
    2. 인증서 송수신과 검증이 이루어진다.
- 과정
    
    ![스크린샷 2025-07-10 오후 9.44.51.jpg](./images/Chapter07/i.jpg)
    
    - **클라이언트의** `ClientHello` 메시지
        - 암호화된 통신을 위해 서로 맞춰봐야 할 정보들을 제시하는 메시지
            - TLS 버전, 사용 가능한 암호화 방식, 해시 함수 등
            - **암호 스위트** : 사용 가능한 암호화 방식과 해시 함수를 담은 정보
                
                ![스크린샷 2025-07-10 오후 9.46.36.jpg](./images/Chapter07/j.jpg)
                
    - **서버의** `ServerHello` 메시지
        - ClientHello에서 제시된 정보들을 선택하는 메시지
            - TLS 버전, 암호 스위트 등
        
        ⇒ 암호화된 통신을 위해 사전 협의해야 할 정보들이 결정되었다.
        
        ⇒ 이 정보를 토대로 서버와 클라는 암호화에 사용할 키를 만들어낼 수 있다.
        
        → TLS의 핵심 1. 암호화 통신을 위한 키를 교환
        
    - **서버의** `Certificate`, `CertificateVerify` 메시지
        - 인증서와 검증을 위한 디지털 서명
    - **서버와** **클라이언트의** `Finished` 메시지
    - 이후 얻어낸 키를 기반으로 암호화된 메시지(Application Data)를 주고받는다!

<aside>

7-2 핵심 포인트

- 대칭 키 암호화 방식은 암호화와 복호화 시 같은 암호 키를 쓰는 암호화 방식
- 공개 키 암호화 방식은 암호화와 복호화 시 서로 다른 키를 쓰는 암호화 방식. 한 키로 암호화했다면 다른 키로 복호화할 수 있다.
- 공개 키 인증서는 공개 키와 공개 키의 유효성을 입증하기 위한 전자문서. CA라는 인증서 발급 기관을 통해 인증서를 검증할 수 있다.
- 개인 키로 암호화된 메시지를 공개 키로 복호화함으로써 신원을 증명하는 절차를 디지털 서명이라 부른다.
- SSL과 TLS는 인증과 암호화를 가능케하는 프로토콜이다. SSL/TLS를 사용하는 가장 대표적인 프로토콜은 HTTPS다.
- TLS 핸드셰이크를 통해 암호화에 사용할 키와 인증서를 주고받을 수 있다.
</aside>

# 7-3 무선 네트워크

- 무선 네트워크에
    - **전파**라는 연결 매체
    - **802.11**라는 표준
    - 그에 기반한 **Wi-Fi 기술**
    - **AP**라는 장비가 있다.

### 전파와 주파수

- **전파**
    - 눈에 보이지 않는 전자기파의 일종
    - 약 3kHz~3THz사이의 진동수를 갖는 전자기파
    - **수많은 무선 통신 기기가 전파를 이용해 통신한다.**
    - 서로 다른 전파 신호가 같은 공간에 혼재하는데, 이는 **주파수로 구분**한다.
- **주파수**
    - 통신에 사용하는 전파를 구분하는 법
    - 나라마다 **주파수 대역, 분배가 따로 정해져있다.**
    - 통신에 사용하는 **인위적 전파**와, 번개 같은 **자연적 전파**와 주파수가 겹치면 통신에 잡음이 생길 수 있다.

### 와이파이와 802.11

- 802.11
    - LAN 환경에서 유선 통신은 IEEE 802.3으로 표준화되어 있다.
    - **LAN 환경에서 무선 통신**은 **IEEE 802.11**로 **표준화**되어 있다.
    - **IEEE 802.11 표준은 대부분 2.4GHz, 5GHz대역**을 사용한다.
        - 와이파이를 선택할 때 2.4G, 5G 글귀가 자주 보이는 이유!
    
    ![스크린샷 2025-07-16 오후 11.17.47.jpg](./images/Chapter07/k.jpg)
    
    - IEEE 802.11 규격에 따라 다른 주파수 대역과 최대 전송 속도
- 와이파이
    - IEEE 802.11 표준을 따르는 무선 LAN 기술
        
        ![스크린샷 2025-07-16 오후 11.20.12.jpg](./images/Chapter07/l.jpg)
        
        - 위의 표준 규격에 따른 주파수 대역과 전송 속도 표를 보면 알 수 있듯이, 와이파이도 세대에 따라 주로 사용하는 주파수 대역과 전송 속도가 달라질 수 있다.
            
            → 이러한 이유로 와이파이는 일종의 인증 마크 역할을 한다.
            
- 채널
    - 같은 주파수 대역을 사용하는 네트워크라 할지라도 별개의 무선 네트워크들이 존재한다.
    - 채널 : 주파수 대역을 세분화. 해당 채널 대역에서 통신이 이루어진다.
        
        ![스크린샷 2025-07-16 오후 11.23.36.jpg](./images/Chapter07/m.jpg)
        
        - 일반적으로 채널은 자동 설정되지만, 수동으로 설정할 수도 있다.
            - 2.4GHz를 보면, 1, 6, 11번 채널처럼 최대한 간섭(중첩)이 덜한 채널을 이용하는 것이 성능에 좋다.
# Chapter07 네트워크 심화

# 7-1 안정성을 위한 기술

- **가용성** : 웹서비스의 안정성을 수치로 표현한 것
    - 전체 사용 시간 중에서 **정상적인 사용 시간**
        
        ![스크린샷 2025-07-04 오후 10.35.15.jpg](attachment:00574f95-03da-4cf4-b1fb-07f5843e7316:스크린샷_2025-07-04_오후_10.35.15.jpg)
        
        - 업타임 - 정상적인 사용 시간
        - 다운타임 - 정상적인 사용이 불가능한 시간
    - **고가용성**(**HA**. High Availability) : 가용성이 높음
        - 모든 웹서비스 업체들의 **대단히 중요한 목표**
        
        ![스크린샷 2025-07-04 오후 10.37.27.jpg](attachment:7327dde6-24fe-4719-a04f-e6bfb8876141:스크린샷_2025-07-04_오후_10.37.27.jpg)
        
        - 항상, 1초도 안 쉬고 잘 돌아가야하는 서비스에서는 파이브 나인스도 치명적
    - **가용성을 높이는 법?**
        
        ⇒ 다운 타임을 낮추면 된다.
        
        - 서비스는 왜 다운될까?
            - 과도한 트래픽
            - 예기치못한 SW상의 오류
            - 하드웨어 장애
            - 보안 공격, 자연재해 등
        - 원인을 모두 원천 차단하기는 힘들다.
        - 따라서 핵심은, **문제가 발생하더라도 계속 기능할 수 있도록 설계하는 것**
            - 이를 **결함 감내**라한다.
- 이중화
    
    : 결함을 감내하여 가용성을 높이기 위한 가장 기본적인 방법으로, **예비(백업)을 마련하는 방법**
    
    - 무엇을 이중화?
        - **문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상**
        - 이를 단일 장애점, **SPOF**(Single Point Of Failure)라고 한다.
            - ex) 서버 컴퓨터, NIC, 스위치, DB, 웹서버프로그램 등
    - 이중화 구성
        1. 액티브/스탠바이
            - 한 시스템은 가동하고, 다른 시스템은 백업 용도로 두는 이중화 구성 방식
            - 장점 : 안전하다
            - 단점 : 성능상 큰 변화는 없다.
        2. 액티브/액티브
            - 두 시스템 모두 가동 상태로 두는 구성 방식
            - 장점 : 부하분산을 할수있다. 성능상 이점이 있다.
            - 단점 : 한 시스템에 문제가 생기면 다른 시스템에 부하가 급증한다.
    - 다중화
        - 시스템을 세 개 이상으로 구성
    - 이중화/다중화 사례
        - **티밍(윈도우)과 본딩(리눅스)**
            - 여러 개의 NIC를 이중화/다중화하여 마치 더 뛰어난 성능을 보유한 하나의 인터페이스처럼 보이게 하는 기술
- 로드 밸런싱
    
    (고가용성을 요구하는 호스트는 일반적으로 클라가 아닌 서버, 서버 중심으로 얘기)
    
    - 서버를 이중화/다중화해도 문제는 남아있다. 바로 트래픽을 분산해야 의미가 있다는 것
    - 한 서버에 트래픽이 몰리면
        - 높은 부하로 CPU 발열 심해짐
        - 메모리 공간 부족
        - 제한된 대역폭과 병목 현상으로 응답이 느려지거나 누락될 수 있음
    
    ---
    
    - 해결 ⇒ 로드 밸런싱(load balancing)
        - load : 부하
        - balancing : 균형 유지
        - 로드 밸런서에 의해 수행된다.
            - L4스위치(전송계층)
            - L7스위치(응용계층)
            - 로드밸런싱 기능을 제공하는 소프트웨어
                - Nginx, HAProxy, Envoy
            
            ![스크린샷 2025-07-05 오전 11.33.03.jpg](attachment:564c02a5-b8a0-4795-b16a-616ff7fcd5e9:스크린샷_2025-07-05_오전_11.33.03.jpg)
            
        
        <aside>
        
        서버의 상태를 검사하는 헬스 체크
        
        - health check
            
            ![스크린샷 2025-07-05 오전 11.35.39.jpg](attachment:f03cdf8e-85d4-4b8b-ae2b-8cf7bcbcb4db:스크린샷_2025-07-05_오전_11.35.39.jpg)
            
            - 서버들의 건강 상태를 주기적으로 모니터링하고 체크
            - 주로 로드 밸런서에 의해 이루어짐
            - HTTP, ICMP 등 다양한 프로토콜 활용
        - 헬스 체크 외에 서버 간의 메시지를 주기적으로 주고받아 상태를 검사하는 **하트비트**라는 방식도 있다.
        </aside>
        
    - 로드 밸런싱 알고리즘
        
        : 로드 밸런서가 부하를 분산시키기 위해 선택하는 방법
        
        1. 라운드 로빈 알고리즘
            
            ![스크린샷 2025-07-05 오전 11.40.23.jpg](attachment:2cf5bce2-f020-401d-bd37-37abacf6498b:스크린샷_2025-07-05_오전_11.40.23.jpg)
            
            - 단순히 돌아가며 부하를 전달하는 방식
        2. 최소 연결 알고리즘
            - 연결이 적은 서버부터 우선적으로 전달하는 방식
        3. 기타
            - 무작위
            - 해시(hash) 자료구조 이용
            - 응답 시간이 가장 짧은 서버 선택
        - 가중치 라운드 로빈 알고리즘, 가중치 최소 연결 알고리즘
            
            ![스크린샷 2025-07-05 오전 11.40.10.jpg](attachment:dbce4074-5ffc-470e-a10e-ab82285d01af:스크린샷_2025-07-05_오전_11.40.10.jpg)
            
            - 1,2번 알고리즘은 서버마다 가중치를 부여할 수 있다.
            - 가중치가 높은 서버가 더 많이 선택되어 더 많은 부하를 받도록 하는 것
            - 서버 간 성능이 다른 경우 주로 사용된다.

## 포워드 프록시와 리버스 프록시

- (HTTP)클라이언트는 서버와 단일하게 딱 붙어있지 않음
    - 실제로는 사이에 수많은 서버가 존재할 수 있고,
    - 서버는 다중화된 경우가 많다.

![스크린샷 2025-07-06 오후 3.08.37.jpg](attachment:1d471b45-c993-4d51-9b26-1cd9e097439e:스크린샷_2025-07-06_오후_3.08.37.jpg)

- 오리진서버
    - 클라이언트가 최종적으로 메시지를 주고받는 대상
    - 자원을 생성하고 클라에게 권한 있는 응답을 보낼 수 있는 HTTP서버
    - 고가용성을 위해 다중화된 경우가 많다.
- 중간서버
    - 인바운드(inbound) 메시지 : 오리진 서버를 향하는 메시지
    - 아웃바운드(outbound) 메시지 : 클라이언트를 향하는 메시지
- 대표적인 HTTP 중간서버
    - 프록시(proxy, 포워드 프록시)
    - 게이트웨이(gateway, 리버스 프록시)

### 프록시(proxy)

- **클라이언트가 선택한** 메시지 전달 대리자
    - 프록시를 언제 어떻게 사용할지는 클라이언트가 선택하기 때문
- 특징
    - 오리진 서버보다 클라이언트와 더 가까이 위치
    - **캐싱, 클라이언트 암호화, 접근 제한 등**

![스크린샷 2025-07-06 오후 3.13.12.jpg](attachment:133162c5-96ad-4712-b923-f2e2402ee536:스크린샷_2025-07-06_오후_3.13.12.jpg)

### 게이트웨이(gateway)

- 일반적 의미 : 네트워크 간의 통신을 가능케 하는 입구 역할을 하는 HW/SW
- HTTP 중간 서버 맥락에서의 의미
    - **아웃바운드 연결에 대해 오리진 서버 역할을 수행**하는 중개자
    - 수신된 요청 메시지를 다른 인바운드 서버들에 전달하는 중개자
- 특징
    - 클라이언트가 보기에 오리진 서버와 같이 보임
    - 클라이언트 요청을 오리진 서버에 전달하기 위해 오리진 서버들에 더 가까이 위치
    - **캐싱, 로드 밸런싱 수행**

![스크린샷 2025-07-06 오후 3.15.54.jpg](attachment:126236eb-ebe3-4a00-a419-d79bd104dbce:스크린샷_2025-07-06_오후_3.15.54.jpg)

# 7-2 안전성을 위한 기술

### 암호와 인증서

- 먼 컴퓨터와 통신할 때 평문으로 메시지를 주고받으면 안된다. 암호화가 필요하다.
- 암호화
    - 원문 데이터를 알아볼 수 없는 형태로 변경하는 것
- 복호화
    - 암호화된 데이터를 원문 데이터로 되돌리는 과정
- 암호화 알고리즘
    - 데이터를 알아보기 어렵게 바꾸는 어떤 수학적 연산
- 암호화 복호화는 비단 안전한 데이터 송수신 뿐만 아니라 인증서 기반의 검증도 가능하게 한다.

### 대칭 키 암호화, 공개 키 암호화

- 대칭 키 암호화
    
    ![스크린샷 2025-07-07 오후 9.44.32.jpg](attachment:24791c09-1ef4-44ac-a29e-b2e16c244387:스크린샷_2025-07-07_오후_9.44.32.jpg)
    
    - 암호화 하는 키와 복호화 하는 키가 같음
    - 장점
        - 작은 부하로 암호화 복호화가 빠르다.
    - 단점
        - 키를 안전하게 전송하기 어렵다.(키 안전하게 전송할 수 있으면 키 말고 그냥 원문 데이터를 안전하게 보내면 되는거 아녀)
- 공개 키 암호화(비대칭 키 암호화)
    
    ![스크린샷 2025-07-07 오후 9.59.42.jpg](attachment:1543308a-c85b-492d-920d-bb88cf1f086d:스크린샷_2025-07-07_오후_9.59.42.jpg)
    
    - 암호화에 사용되는 키와 복호화에 사용되는 키가 다름
    - 한 쌍의 키(공개 키, 개인 키)를 사용 : 한 키로 암호화, 다른 키로 복호화
    - 공개 키(public key)를 알아도 개인 키(private key) 유추 불가능. 역도 마찬가지
    - 공개 키는 암호화만 하고 개인 키를 유추할 수 없기 때문에 누구에게나 공개해도 무방하다.
    - 다시 받은 쪽에서 답장 메시지를 보낼때(B→A. 사실 A→B의 과정과 동일하다.)
        - A는 자신의 공개키를 B에게 전달
        - B는 A의 공개 키로 메시지를 암호화한 뒤 A에게 전송
        - A는 개인 키로 암호를 복호화해서 B의 메시지 확인
    - 장점
        - 키를 안전하게 공유할 수 있다
    - 단점
        - 암호화 및 복호화에 시간과 부하가 상대적으로 많이 든다.

### 인증서와 디지털 서명

> 앞서 본 암호화 기술을 기반으로 수행할 수 있는 인증, 디지털 서명
> 
- 인증서
    - 무엇인가를 증명하기 위한 문서
    - 네트워크(인터넷)에서의 인증서 = 일반적으로 ‘공개 키 인증서’

- 공개 키 인증서
    - ‘이 공개 키가 유효합니다.’ 인증하는 전자 문서
    - 공개 키와 공개 키의 유효성을 입증하기 위한 전자 문서
    
    ![image.png](attachment:94a69807-ec57-469e-9587-22d94de65813:image.png)
    
    - 인증기관인 **CA**가 발급해줌
        - 통신 주체가 인증서를 가지고 있는건 의미가 없음(어케 믿어)
        - 인증서의 발급, 검증, 저장과 같은 역할을 수행할 수 있는 공인기관
        - 대표적인 인증 기관 - IdenTrust, DigiCert, GlobalSign 등
    - 서명 값(signature)
        
        ![image.png](attachment:a8117d71-81af-4fc4-99ea-c49e0393c320:image.png)
        
        - 인증 기관의 인증 정보
        - 이 공개 키 인증서는 진짜임을 보증하는 것
        - 클라이언트는 CA가 발급한 인증서의 서명 값을 바탕으로 인증서 검증
        - 서명 값 생성의 원리
            
            ![image.png](attachment:d57b856c-438d-4c1c-b3a7-63eaf50d4c92:image.png)
            
            1. 인증서 내용에 대한 해시 값을
            2. CA의 개인 키로 암호화하는 방식으로 생성
                - CA는 이렇게 얻어낸 정보를 서명 값으로 삼아 클라이언트에게 인증서와 함께 전송
            
            ⇒ CA가 뿌린 공개키로 복호화가 됐다는건, CA가 개인키로 암호화한 데이터니까 CA가 인증한 인증서가 맞구나!를 알 수 있음
            
            - 1의 결과인 인증서 내용에 대한 해시 값을 fingerprint라고도 함
            
            <aside>
            💡
            
            해시 값?
            
            - 해시 함수를 적용시킨 결괏값
                - 해시 함수란
                    - 임의의 길이의 데이터를 고정된 길이의 데이터로 변환하는 함수
                    - MD5, SHA-1, SHA-2(SHA-256, SHA-384, SHA-512)등
                    - 입력값에 민감 : 입력 데이터가 조금만 달라져도 완전히 다른 결과가 나옴
            - 데이터 변조 여부 검사에 사용
                1. ‘보낼 데이터’ 와 ‘데이터에 대한 해시 값’을 함께 전송
                2. 수신자가 전달 받은 데이터에 대한 해시 값을 직접 계산
                3. 계산 결과를 전달 받은 해시 값과 비교
                4. 같은 값이 도출된다면 ⇒ 데이터 전송 도중 변조되거나 소실되지 않았다고 판단
            </aside>
            
    - 인증서 검증 과정
        
        ![image.png](attachment:0b5bd994-8ba6-4418-9750-8e5ae6c090bc:image.png)
        
        1. 서명 값과 인증서 분리
        2. 서명 값을 CA의 공개 키로 복호화하여 인증서 내용에 대한 해시 값을 얻음 
        3. 인증서 데이터에 대한 해시 값을 직접 계산
        4. 이를 복호화한 값과 비교
        
        → 만일 값이 일치한다면? 전달 받은 인증서는 확실히 CA의 개인 키로 만들어졌다고 보장
        
        ### 디지털 서명
        
        - 개인 키로 암호화된 메시지를 공개 키로 복호화함으로써 신원을 증명하는 절차

### HTTPS : SSL/TLS

- 지금까지 배운 대칭 키 / 공개 키 암호화, 그리고 공개 키 인증서를 기반으로 동작하는 프로토콜로 SSL과 TLS가 있다.
    - TLS는 SSL을 계승한 프로토콜이다.
- 이 SSL/TLS를 대표적으로 사용하는 프로토콜은 **HTTPS**(HTTP over TLS)이다.
    
    ![스크린샷 2025-07-10 오후 9.41.26.jpg](attachment:02ce6c8a-8139-4028-b5f5-88e590ad992c:스크린샷_2025-07-10_오후_9.41.26.jpg)
    

### HTTP 동작 과정(TLS 1.3 기반)

1. TCP 3-way 핸드셰이크
    1. SYN / SYN+ACK / ACK 세그먼트
2. **TLS 핸드셰이크**
3. 암호화된 메시지 송수신

### TLS 핸드셰이크

- 핵심
    1. 암호화 통신을 위한 키를 교환한다.
    2. 인증서 송수신과 검증이 이루어진다.
- 과정
    
    ![스크린샷 2025-07-10 오후 9.44.51.jpg](attachment:056e0335-28fa-452e-acbc-dd12ec6eab87:스크린샷_2025-07-10_오후_9.44.51.jpg)
    
    - **클라이언트의** `ClientHello` 메시지
        - 암호화된 통신을 위해 서로 맞춰봐야 할 정보들을 제시하는 메시지
            - TLS 버전, 사용 가능한 암호화 방식, 해시 함수 등
            - **암호 스위트** : 사용 가능한 암호화 방식과 해시 함수를 담은 정보
                
                ![스크린샷 2025-07-10 오후 9.46.36.jpg](attachment:24510d35-27a0-4056-947a-0cf94f18444c:스크린샷_2025-07-10_오후_9.46.36.jpg)
                
    - **서버의** `ServerHello` 메시지
        - ClientHello에서 제시된 정보들을 선택하는 메시지
            - TLS 버전, 암호 스위트 등
        
        ⇒ 암호화된 통신을 위해 사전 협의해야 할 정보들이 결정되었다.
        
        ⇒ 이 정보를 토대로 서버와 클라는 암호화에 사용할 키를 만들어낼 수 있다.
        
        → TLS의 핵심 1. 암호화 통신을 위한 키를 교환
        
    - **서버의** `Certificate`, `CertificateVerify` 메시지
        - 인증서와 검증을 위한 디지털 서명
    - **서버와** **클라이언트의** `Finished` 메시지
    - 이후 얻어낸 키를 기반으로 암호화된 메시지(Application Data)를 주고받는다!

<aside>

7-2 핵심 포인트

- 대칭 키 암호화 방식은 암호화와 복호화 시 같은 암호 키를 쓰는 암호화 방식
- 공개 키 암호화 방식은 암호화와 복호화 시 서로 다른 키를 쓰는 암호화 방식. 한 키로 암호화했다면 다른 키로 복호화할 수 있다.
- 공개 키 인증서는 공개 키와 공개 키의 유효성을 입증하기 위한 전자문서. CA라는 인증서 발급 기관을 통해 인증서를 검증할 수 있다.
- 개인 키로 암호화된 메시지를 공개 키로 복호화함으로써 신원을 증명하는 절차를 디지털 서명이라 부른다.
- SSL과 TLS는 인증과 암호화를 가능케하는 프로토콜이다. SSL/TLS를 사용하는 가장 대표적인 프로토콜은 HTTPS다.
- TLS 핸드셰이크를 통해 암호화에 사용할 키와 인증서를 주고받을 수 있다.
</aside>

# 7-3 무선 네트워크

- 무선 네트워크에
    - **전파**라는 연결 매체
    - **802.11**라는 표준
    - 그에 기반한 **Wi-Fi 기술**
    - **AP**라는 장비가 있다.

### 전파와 주파수

- **전파**
    - 눈에 보이지 않는 전자기파의 일종
    - 약 3kHz~3THz사이의 진동수를 갖는 전자기파
    - **수많은 무선 통신 기기가 전파를 이용해 통신한다.**
    - 서로 다른 전파 신호가 같은 공간에 혼재하는데, 이는 **주파수로 구분**한다.
- **주파수**
    - 통신에 사용하는 전파를 구분하는 법
    - 나라마다 **주파수 대역, 분배가 따로 정해져있다.**
    - 통신에 사용하는 **인위적 전파**와, 번개 같은 **자연적 전파**와 주파수가 겹치면 통신에 잡음이 생길 수 있다.

### 와이파이와 802.11

- 802.11
    - LAN 환경에서 유선 통신은 IEEE 802.3으로 표준화되어 있다.
    - **LAN 환경에서 무선 통신**은 **IEEE 802.11**로 **표준화**되어 있다.
    - **IEEE 802.11 표준은 대부분 2.4GHz, 5GHz대역**을 사용한다.
        - 와이파이를 선택할 때 2.4G, 5G 글귀가 자주 보이는 이유!
    
    ![스크린샷 2025-07-16 오후 11.17.47.jpg](attachment:c75e2441-4f31-4656-b521-6bece15783b9:스크린샷_2025-07-16_오후_11.17.47.jpg)
    
    - IEEE 802.11 규격에 따라 다른 주파수 대역과 최대 전송 속도
- 와이파이
    - IEEE 802.11 표준을 따르는 무선 LAN 기술
        
        ![스크린샷 2025-07-16 오후 11.20.12.jpg](attachment:03ddd3f8-4bff-4881-9221-006b9112edde:스크린샷_2025-07-16_오후_11.20.12.jpg)
        
        - 위의 표준 규격에 따른 주파수 대역과 전송 속도 표를 보면 알 수 있듯이, 와이파이도 세대에 따라 주로 사용하는 주파수 대역과 전송 속도가 달라질 수 있다.
            
            → 이러한 이유로 와이파이는 일종의 인증 마크 역할을 한다.
            
- 채널
    - 같은 주파수 대역을 사용하는 네트워크라 할지라도 별개의 무선 네트워크들이 존재한다.
    - 채널 : 주파수 대역을 세분화. 해당 채널 대역에서 통신이 이루어진다.
        
        ![스크린샷 2025-07-16 오후 11.23.36.jpg](attachment:a384831f-1010-420e-8d8c-51c40341f755:스크린샷_2025-07-16_오후_11.23.36.jpg)
        
        - 일반적으로 채널은 자동 설정되지만, 수동으로 설정할 수도 있다.
            - 2.4GHz를 보면, 1, 6, 11번 채널처럼 최대한 간섭(중첩)이 덜한 채널을 이용하는 것이 성능에 좋다.

### AP와 서비스 셋

- **AP(Access Point)**
    
    : 무선 통신 기기들을 연결하여 무선 네트워크를 구성하는 장치
    
    - ex) 가정의 무선 공유기
    - 일반적으로 AP에는 유선 연결 매체를 연결할 수 있는 지점도 함께 제공
        - → 유선 네트워크와 무선 네트워크의 연결을 담당하는 역할도 수행
    - **인프라스트럭처 모드**
        
        : AP를 경유하여 통신이 이루어지는 무선 네트워크 통신 방식
        
        - 오늘날 많은 무선 LAN이 AP가 중개하는 인프라스트럭처 모드로 동작한다.
        - **하나의 AP**만으로 구성된 무선 LAN을 **BSS**(Basic Service Set)이라 하고, **여러 AP**로 구성된 무선 LAN을 **ESS**(Extended Service Set)이라 한다.
    - 애드 혹 모드(Ad Hoc mode) : AP의 간섭 없이 호스트 간에 일대일로 통신하는 무선 통신 모드
- **서비스 셋**
    
    ![스크린샷 2025-07-21 오후 9.13.40.jpg](./images/Chapter07/ServiceSet.jpg)
    
    : 무선 네트워크를 이루는 AP와 여러 장치들의 집합
    
    = 같은 서비스 셋에 속한 장치들은 같은 무선 네트워크에 속한다.
    
    - **SSID**
        - 각기 다른 서비스 셋을 구분하는 수단
            
            **= 와이파이 이름**
            
    - **비컨 프레임**
        - AP는 외부에 자신의 존재를 지속해서 알려야 한다.
            - 그렇지 않으면 호스트는 연결 가능한 무선 네트워크가 존재한다는 사실을 모른다.
        - AP가 불특정 다수 모두에게 자신을 알리는 브로드캐스트 메시지를 주기적으로 전송하는데, 이 브로드캐스트 메시지를 **비컨프레임**이라한다.
            - 비컨 프레임에는 SSID, AP의 MAC주소 등이 포함되어 있다.
            - **와이파이 목록들이 쫙 뜨는 건 우리 장치가 AP로부터 비컨 프레임을 받았기 때문이다.**